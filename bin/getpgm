#!/usr/bin/env python

# stdlib imports
import argparse
from collections import OrderedDict
import datetime
import glob
import importlib
import inspect
import os.path
import pkgutil
import sys
import warnings

# local imports
from amptools.exception import AmptoolsException
from amptools.process import filter_detrend
from amptools.stream import group_channels
from pgm.exception import PGMException
from pgm.gather import get_pgm_classes
from pgm.station_summary import StationSummary

# third party imports
import pandas as pd


EXCLUDED_MODULES = ['base.py', '__init__.py']
VALID_FORMATS = ['cosmos', 'cwb', 'dmg', 'geonet', 'knet']


def get_timeseries(input_source, input_format):
    """
    Read files from a directory and return stream objects.

    Args:
        input_source (str): Path to input files.
        input_format (str): File format.

    Returns:
        list: List of obspy.core.stream.Stream objects
    """
    # TODO: If input_format == db, get from COMCAT and CWB
    # Check that the file format is valid
    if input_format.lower() not in VALID_FORMATS:
        raise AmptoolsException('%r is not a supported format. Supported '
                'formats are: %r' % (input_format, VALID_FORMATS))
    # Create the module and function name from the request
    reader = 'amptools.io.' + input_format + '.core'
    function_name = 'read_' + input_format
    # Import modeule and function
    reader_module = importlib.import_module(reader)
    read_method =  getattr(reader_module, function_name)
    # Read, group, and return streams
    streams = []
    for file_path in glob.glob(input_source + '/*'):
        streams += [read_method(file_path)]
    streams = group_channels(streams)
    return streams


def main(args):
    """
    Loop over requested pgm types and call module.getPGM() for each valid
    request.

    Args:
        ArgumentParser: argparse argument object.
    """
    # Check import arguments
    if args.input_source is not None:
        input_source = args.input_source
    else:
        raise PGMException('No input source specified.')
    if args.output_directory is not None:
        output_directory = args.output_directory
        # Create directory if it doesn't exist
        if not os.path.exists(output_directory):
                os.makedirs(output_directory)
    else:
        raise PGMException('No output directory specified.')
    if args.format is not None:
        input_format = args.format
    else:
        raise AmptoolsException('No input format specified.')
    if len(args.measurements) < 1:
         raise PGMException('No measurement type specified.')
    # Get streams
    streams = get_timeseries(input_source, input_format)
    # Process the data
    # TODO: Bypass process if pulling processed streams from CWB
    with warnings.catch_warnings():
        warnings.simplefilter("ignore")
        streams = process_streams(streams)
    flat_list = []
    for idx, stream in enumerate(streams):
        summary = StationSummary(stream, args.components,
                args.measurements, damping=0.05)
        flat_rows = summary.create_flatfile_rows()
        flat_list += [flat_rows]
        table = summary.create_table()
        # Create file path
        station = stream[0].stats['station']
        filename = station + '.csv'
        path = os.path.join(output_directory, filename)
        # Export csv
        writer = table.to_csv(path, mode = 'w', index=False)
    all_rows = pd.concat(flat_list)
    # Create file path
    today = datetime.datetime.now().strftime("%Y_%m_%d")
    filename = today + '_flatfile.csv'
    path = os.path.join(output_directory, filename)
    # Export csv
    writer = all_rows.to_csv(path, mode = 'w', index=False)



def process_streams(streams):
    """
    Perform basic processing on streams.

    Args:
        streams (list): List of streams (obspy.core.stream.Stream).

    Returns:
        list: List of obspy.core.stream.Stream objects
    """
    # TODO: Possibly let the user pick the filter settings
    for stream in streams:
        for idx, trace in enumerate(stream):
            stream[idx] = filter_detrend(trace, taper_type='cosine',
                    taper_percentage=0.05, filter_type='highpass',
                    filter_frequency=0.02, filter_zerophase=True,
                    filter_corners=4)
    return streams


def _get_parser():
    """
    Internal method to get argparse parser instance.

    Returns:
        ArgumentParser: argparse argument parser.
    """
    description = '''
    Get requested PGM values.
    '''
    # Get valid classes
    _imt_classes_ = get_pgm_classes('imt')
    _imc_classes_ = get_pgm_classes('imc')
    # Create descriptions
    epilog = 'PGM Parameters:\n'
    epilog += '\tAvailable IMTs:\n'
    for func in _imt_classes_:
        epilog += '\t\t- %s\n' % func[10:]
    epilog += '\tAvailable IMCs:\n'
    for func in _imc_classes_:
        epilog += '\t\t- %s\n' % func[10:]

    epilog += '\nFor parameters with specific percentiles or periods,\n' + \
            'append the number on the end of the parameter string\n' + \
            'Example spectral amplitude: sa1.0\n' + \
            'Example geometric mean rotation: gmrotd50\n'
    # Define parser arguments
    parser = argparse.ArgumentParser(
        description=description,
        epilog=epilog,
        formatter_class=argparse.RawDescriptionHelpFormatter)
    parser.add_argument('input_source',
                        help='The directory of all input files.')
    parser.add_argument('output_directory',
                        help='The directory of all output files.')
    parser.add_argument('format',
                        help='Format of the files that are read in.')
    parser.add_argument('-c', '--components', nargs='+', dest='components',
            default=[], help='The IMC parameters to get.', required=True)
    parser.add_argument('-m', '--measurements', nargs='+', dest='measurements',
            default=[], help='The IMT parameters to get.', required=True)
    return parser


if __name__ == '__main__':
    parser = _get_parser()
    pargs = parser.parse_args()
    if pargs.input_source.lower() == 'help' and len(pargs.intensity_measurements) == 0:
        parser.print_help()
    else:
        main(pargs)
    sys.exit(0)
